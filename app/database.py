"""
==============================================================================
데이터베이스 연결 모듈 (database.py)
==============================================================================

이 파일은 데이터베이스와의 연결을 담당합니다.

연결 흐름:
    1. config.py에서 DATABASE_URL을 가져옴
    2. SQLAlchemy 엔진 생성 (DB와 통신하는 객체)
    3. 세션 팩토리 생성 (실제 쿼리를 실행하는 객체)

비동기(async) 방식을 사용하는 이유:
    - 여러 요청을 동시에 처리할 수 있음
    - DB 응답을 기다리는 동안 다른 요청 처리 가능
    - 서버 성능 향상

==============================================================================
"""

from sqlalchemy.ext.asyncio import (
    create_async_engine,    # 비동기 DB 엔진 생성 함수
    AsyncSession,           # 비동기 세션 클래스
    async_sessionmaker,     # 비동기 세션 생성기
)
from sqlalchemy.orm import DeclarativeBase  # 모델의 기본 클래스

from app.config import get_settings  # 설정 가져오기

# 설정 객체 가져오기
settings = get_settings()


# =============================================================================
# 데이터베이스 엔진 생성
# =============================================================================
#
# 엔진(Engine)이란?
#   - DB와 실제로 통신하는 객체
#   - 연결 풀(Connection Pool)을 관리
#   - 마치 "DB로 가는 고속도로"와 같음
#
# echo 옵션:
#   - True: 실행되는 SQL 쿼리를 콘솔에 출력 (디버깅용)
#   - False: SQL 출력 안 함 (프로덕션용)
#
engine = create_async_engine(
    settings.database_url,  # DB 주소 (config.py에서 가져옴)
    echo=settings.debug,    # 디버그 모드면 SQL 출력
)


# =============================================================================
# 세션 팩토리 생성
# =============================================================================
#
# 세션(Session)이란?
#   - DB와의 대화 단위
#   - 하나의 요청(Request)마다 하나의 세션 사용
#
# 팩토리(Factory)란?
#   - 필요할 때마다 새 세션을 만들어줌
#
# expire_on_commit=False:
#   - 커밋 후에도 데이터를 다시 읽지 않음 (성능 최적화)
#
AsyncSessionLocal = async_sessionmaker(
    engine,                   # 사용할 엔진
    class_=AsyncSession,      # 비동기 세션 클래스 사용
    expire_on_commit=False,   # 커밋 후 데이터 만료 안 함
)


# =============================================================================
# 모델 기본 클래스
# =============================================================================
#
# 모든 DB 테이블 모델은 이 클래스를 상속받습니다.
# 이렇게 하면 SQLAlchemy가 모든 테이블을 추적할 수 있습니다.
#
# 예: class News(Base):  <- Base를 상속받음
#         ...
#
class Base(DeclarativeBase):
    """
    모든 DB 모델의 부모 클래스
    
    이 클래스를 상속받은 모든 클래스는 자동으로 DB 테이블이 됩니다.
    """
    pass


# =============================================================================
# 세션 의존성 함수
# =============================================================================
#
# FastAPI의 "의존성 주입(Dependency Injection)" 패턴
#
# 작동 방식:
#   1. API 요청이 들어옴
#   2. get_db() 함수가 호출되어 세션 생성
#   3. API 함수에서 세션 사용
#   4. API 응답 후 세션 자동 종료
#
# 이렇게 하면:
#   - 매 요청마다 새로운 세션 사용 (안전)
#   - 요청 끝나면 자동으로 세션 정리 (메모리 누수 방지)
#
async def get_db():
    """
    DB 세션을 생성하고 반환하는 함수
    
    FastAPI의 Depends()와 함께 사용됩니다.
    
    사용 예시:
        @router.get("/news")
        async def get_news(db: AsyncSession = Depends(get_db)):
            # db를 사용하여 쿼리 실행
            ...
    
    Yields:
        AsyncSession: DB 세션 객체
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session  # 세션을 API 함수에 전달
        finally:
            await session.close()  # 사용 후 반드시 세션 닫기


# =============================================================================
# 테이블 초기화 함수
# =============================================================================
#
# 기존 DB의 테이블을 사용하므로 테이블 생성을 하지 않습니다.
# 단, DB 연결 확인용으로 함수는 유지합니다.
#
async def init_db():
    """
    데이터베이스 연결을 확인하는 함수
    
    서버 시작 시 main.py에서 호출됩니다.
    
    주의: 기존 DB의 테이블(naver_news, filtered_news)을 사용하므로
          테이블 자동 생성(create_all)은 비활성화되어 있습니다.
    """
    # 기존 테이블 사용 - 자동 생성 비활성화
    # async with engine.begin() as conn:
    #     await conn.run_sync(Base.metadata.create_all)
    pass
