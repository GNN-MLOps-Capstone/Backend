# ==============================================================================
# Backend API Dockerfile
# ==============================================================================
#
# Docker란?
#   - 애플리케이션을 "컨테이너"라는 격리된 환경에서 실행
#   - 어디서든 동일한 환경으로 실행 가능 (내 PC든 서버든)
#   - "이 컴퓨터에서는 되는데 왜 저기서 안 돼요?" 문제 해결
#
# 이미지 vs 컨테이너?
#   - 이미지: 설계도 (Dockerfile로 생성)
#   - 컨테이너: 실제로 실행되는 것 (이미지로부터 생성)
#   - 마치 클래스(이미지)와 인스턴스(컨테이너) 관계!
#
# 빌드 명령어:
#   docker build -t news-api .
#
# 실행 명령어:
#   docker run -p 8000:8000 news-api
#
# ==============================================================================


# =============================================================================
# 베이스 이미지 선택
# =============================================================================
# FROM: 시작점이 될 이미지를 지정합니다.
#
# python:3.11-slim 의미:
#   - python: Python 공식 이미지
#   - 3.11: Python 버전
#   - slim: 경량 버전 (불필요한 패키지 제외, 이미지 크기 줄임)
#
# 다른 옵션:
#   - python:3.11 (일반 버전, 크기 큼)
#   - python:3.11-alpine (최소 버전, 일부 패키지 호환 문제 가능)
#
FROM python:3.11-slim


# =============================================================================
# 작업 디렉토리 설정
# =============================================================================
# WORKDIR: 컨테이너 안에서 작업할 폴더를 지정합니다.
# 이후의 모든 명령어는 이 폴더에서 실행됩니다.
#
# 마치 cd /app 하고 작업하는 것과 같습니다.
#
WORKDIR /app


# =============================================================================
# 환경 변수 설정
# =============================================================================
# ENV: 컨테이너 안에서 사용할 환경 변수를 설정합니다.
#
# PYTHONDONTWRITEBYTECODE=1
#   - Python이 .pyc 파일을 생성하지 않음
#   - 컨테이너 크기 절약
#
# PYTHONUNBUFFERED=1
#   - Python 출력을 버퍼링하지 않음
#   - 로그가 실시간으로 출력됨 (디버깅에 유용)
#
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1


# =============================================================================
# 시스템 패키지 설치
# =============================================================================
# RUN: 이미지 빌드 시 실행할 명령어입니다.
#
# apt-get update: 패키지 목록 업데이트
# apt-get install: 패키지 설치
#   - gcc: C 컴파일러 (일부 Python 패키지 빌드에 필요)
# --no-install-recommends: 추천 패키지 설치 안 함 (크기 절약)
# rm -rf /var/lib/apt/lists/*: 설치 후 캐시 삭제 (크기 절약)
#
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*


# =============================================================================
# 의존성 파일 복사 및 설치
# =============================================================================
# COPY: 호스트(내 컴퓨터)의 파일을 컨테이너로 복사합니다.
#
# 왜 requirements.txt만 먼저 복사하나요?
#   Docker는 레이어(층) 구조로 이미지를 만듭니다.
#   코드가 바뀌어도 requirements.txt가 안 바뀌면
#   패키지 설치 단계를 건너뛸 수 있습니다. (빌드 속도 향상)
#
COPY requirements.txt .

# pip 업그레이드 및 패키지 설치
# --no-cache-dir: 캐시 저장 안 함 (이미지 크기 절약)
#
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt


# =============================================================================
# 애플리케이션 코드 복사
# =============================================================================
# COPY . .: 현재 폴더의 모든 파일을 컨테이너의 /app으로 복사
#
# .dockerignore 파일이 있으면 특정 파일/폴더 제외 가능
#   예: __pycache__, .git, .env 등
#
COPY . .


# =============================================================================
# 시작 스크립트 설정
# =============================================================================
# entrypoint.sh: 컨테이너가 시작될 때 실행되는 스크립트
# chmod +x: 실행 권한 부여
#
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh


# =============================================================================
# 포트 노출
# =============================================================================
# EXPOSE: 컨테이너가 사용할 포트를 문서화합니다.
#
# 실제로 포트를 열지는 않습니다!
#   docker run -p 8000:8000 으로 실행해야 외부에서 접근 가능
#
# 형식: -p [호스트포트]:[컨테이너포트]
#   예: -p 80:8000 -> localhost:80 -> 컨테이너:8000
#
EXPOSE 8000


# =============================================================================
# 헬스 체크 설정
# =============================================================================
# HEALTHCHECK: 컨테이너가 정상 작동하는지 주기적으로 확인
#
# --interval=30s: 30초마다 체크
# --timeout=10s: 10초 안에 응답 없으면 실패
# --start-period=5s: 컨테이너 시작 후 5초 대기 (초기화 시간)
# --retries=3: 3번 연속 실패하면 unhealthy 상태
#
# CMD: 헬스 체크에 사용할 명령어
#   - /health 엔드포인트에 요청을 보내 응답 확인
#
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1


# =============================================================================
# 컨테이너 시작 명령어
# =============================================================================
# ENTRYPOINT: 컨테이너가 시작될 때 실행할 명령어
#
# entrypoint.sh 스크립트가 실행되며:
#   1. 필요시 DB 초기화
#   2. uvicorn 서버 시작
#
# CMD vs ENTRYPOINT:
#   - ENTRYPOINT: 항상 실행되는 명령어
#   - CMD: ENTRYPOINT의 인자 또는 기본 명령어
#
ENTRYPOINT ["/entrypoint.sh"]
